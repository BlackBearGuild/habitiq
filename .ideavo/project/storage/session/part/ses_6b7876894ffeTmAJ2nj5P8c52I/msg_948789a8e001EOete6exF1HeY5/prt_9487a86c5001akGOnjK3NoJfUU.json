{
  "id": "prt_9487a86c5001akGOnjK3NoJfUU",
  "messageID": "msg_948789a8e001EOete6exF1HeY5",
  "sessionID": "ses_6b7876894ffeTmAJ2nj5P8c52I",
  "type": "tool",
  "tool": "write",
  "callID": "toolu_01Md6ReLkjRwSeA71Bbegtye",
  "state": {
    "status": "completed",
    "input": {
      "filePath": "/home/user/project/components/smart-reminders.tsx",
      "content": "\"use client\";\n\nimport { useState, useEffect } from 'react';\nimport { Clock, Bell, CheckCircle2, XCircle, Calendar, Zap, AlertCircle } from 'lucide-react';\nimport { Card, CardContent, CardHeader, CardTitle } from '@/components/ui/card';\nimport { Button } from '@/components/ui/button';\nimport { Badge } from '@/components/ui/badge';\nimport { Switch } from '@/components/ui/switch';\n\ninterface Note {\n  id: string;\n  content: string;\n  transcript?: string;\n  timestamp: string;\n  type: 'text' | 'voice';\n  tags?: string[];\n}\n\ninterface Reminder {\n  id: string;\n  noteId: string;\n  text: string;\n  extractedFrom: string;\n  priority: 'high' | 'medium' | 'low';\n  category: string;\n  suggestedTime?: string;\n  isCompleted: boolean;\n  isDismissed: boolean;\n  createdAt: string;\n}\n\ninterface SmartRemindersProps {\n  notes: Note[];\n}\n\nexport function SmartReminders({ notes }: SmartRemindersProps) {\n  const [reminders, setReminders] = useState<Reminder[]>([]);\n  const [showCompleted, setShowCompleted] = useState(false);\n  const [notificationsEnabled, setNotificationsEnabled] = useState(false);\n\n  useEffect(() => {\n    const extractedReminders = extractRemindersFromNotes(notes);\n    setReminders(prev => {\n      // Merge new reminders with existing ones, preserving completion status\n      const existingMap = new Map(prev.map(r => [r.noteId + r.text, r]));\n      \n      return extractedReminders.map(newReminder => {\n        const key = newReminder.noteId + newReminder.text;\n        const existing = existingMap.get(key);\n        return existing ? { ...newReminder, isCompleted: existing.isCompleted, isDismissed: existing.isDismissed } : newReminder;\n      });\n    });\n  }, [notes]);\n\n  useEffect(() => {\n    // Request notification permission on component mount\n    if ('Notification' in window && Notification.permission === 'default') {\n      Notification.requestPermission().then(permission => {\n        setNotificationsEnabled(permission === 'granted');\n      });\n    } else if ('Notification' in window && Notification.permission === 'granted') {\n      setNotificationsEnabled(true);\n    }\n  }, []);\n\n  const extractRemindersFromNotes = (notes: Note[]): Reminder[] => {\n    const reminders: Reminder[] = [];\n    \n    notes.forEach(note => {\n      const text = note.transcript || note.content;\n      const lowerText = text.toLowerCase();\n      \n      // Patterns for reminder extraction\n      const reminderPatterns = [\n        /(?:remind me to|remember to|need to|have to|should|must|don't forget to)\\s+(.+?)(?:\\.|$|\\n)/gi,\n        /(?:tomorrow|today|later|this week|next week|this month).*?(exercise|workout|drink|water|call|meeting|appointment|task)/gi,\n        /(exercise|workout|gym|run|walk|jog|stretch|yoga)(?:\\s+(?:tomorrow|today|later|this week))?/gi,\n        /(drink|water|hydrate)(?:\\s+(?:more|enough|regularly))?/gi,\n        /(sleep|bed|rest)(?:\\s+(?:early|earlier|better|enough))?/gi,\n        /(meditat|mindfulness|breathe)(?:\\s+(?:daily|regularly))?/gi,\n        /(read|study|learn)(?:\\s+(?:more|daily|tonight))?/gi,\n      ];\n\n      reminderPatterns.forEach(pattern => {\n        let match;\n        while ((match = pattern.exec(text)) !== null) {\n          const reminderText = match[1] || match[0];\n          if (reminderText && reminderText.length > 3) {\n            reminders.push({\n              id: `${note.id}-${Date.now()}-${Math.random()}`,\n              noteId: note.id,\n              text: reminderText.trim(),\n              extractedFrom: text.substring(Math.max(0, match.index - 20), match.index + match[0].length + 20),\n              priority: determinePriority(reminderText),\n              category: categorizeReminder(reminderText),\n              suggestedTime: extractTimeHint(text),\n              isCompleted: false,\n              isDismissed: false,\n              createdAt: note.timestamp\n            });\n          }\n        }\n      });\n    });\n\n    // Remove duplicates based on similarity\n    const uniqueReminders = reminders.filter((reminder, index) => {\n      return !reminders.slice(0, index).some(existing => \n        similarity(existing.text, reminder.text) > 0.7\n      );\n    });\n\n    return uniqueReminders.sort((a, b) => {\n      const priorityOrder = { high: 3, medium: 2, low: 1 };\n      return priorityOrder[b.priority] - priorityOrder[a.priority];\n    });\n  };\n\n  const similarity = (str1: string, str2: string): number => {\n    const longer = str1.length > str2.length ? str1 : str2;\n    const shorter = str1.length > str2.length ? str2 : str1;\n    const editDistance = levenshteinDistance(longer, shorter);\n    return (longer.length - editDistance) / longer.length;\n  };\n\n  const levenshteinDistance = (str1: string, str2: string): number => {\n    const matrix = [];\n    for (let i = 0; i <= str2.length; i++) {\n      matrix[i] = [i];\n    }\n    for (let j = 0; j <= str1.length; j++) {\n      matrix[0][j] = j;\n    }\n    for (let i = 1; i <= str2.length; i++) {\n      for (let j = 1; j <= str1.length; j++) {\n        if (str2.charAt(i - 1) === str1.charAt(j - 1)) {\n          matrix[i][j] = matrix[i - 1][j - 1];\n        } else {\n          matrix[i][j] = Math.min(\n            matrix[i - 1][j - 1] + 1,\n            matrix[i][j - 1] + 1,\n            matrix[i - 1][j] + 1\n          );\n        }\n      }\n    }\n    return matrix[str2.length][str1.length];\n  };\n\n  const determinePriority = (text: string): 'high' | 'medium' | 'low' => {\n    const highPriorityWords = ['urgent', 'important', 'asap', 'immediately', 'critical', 'deadline'];\n    const lowPriorityWords = ['maybe', 'eventually', 'someday', 'if possible'];\n    \n    const lowerText = text.toLowerCase();\n    \n    if (highPriorityWords.some(word => lowerText.includes(word))) return 'high';\n    if (lowPriorityWords.some(word => lowerText.includes(word))) return 'low';\n    \n    return 'medium';\n  };\n\n  const categorizeReminder = (text: string): string => {\n    const lowerText = text.toLowerCase();\n    \n    if (lowerText.match(/(exercise|workout|gym|run|walk|jog|stretch|yoga|fitness)/)) return 'fitness';\n    if (lowerText.match(/(drink|water|hydrate)/)) return 'hydration';\n    if (lowerText.match(/(sleep|bed|rest)/)) return 'sleep';\n    if (lowerText.match(/(meditat|mindfulness|breathe)/)) return 'mindfulness';\n    if (lowerText.match(/(read|study|learn)/)) return 'learning';\n    if (lowerText.match(/(call|meeting|appointment|work)/)) return 'work';\n    if (lowerText.match(/(eat|meal|food|cook)/)) return 'nutrition';\n    \n    return 'general';\n  };\n\n  const extractTimeHint = (text: string): string | undefined => {\n    const timePatterns = [\n      /tomorrow/i,\n      /today/i,\n      /tonight/i,\n      /this morning/i,\n      /this afternoon/i,\n      /this evening/i,\n      /this week/i,\n      /next week/i,\n      /this month/i,\n    ];\n\n    for (const pattern of timePatterns) {\n      if (pattern.test(text)) {\n        return pattern.source.replace(/[\\/\\\\^$*+?.()|[\\]{}]/g, '').replace('i', '');\n      }\n    }\n    \n    return undefined;\n  };\n\n  const completeReminder = (reminderId: string) => {\n    setReminders(prev => \n      prev.map(r => \n        r.id === reminderId \n          ? { ...r, isCompleted: !r.isCompleted }\n          : r\n      )\n    );\n    \n    if (notificationsEnabled) {\n      new Notification('HabitIQ', {\n        body: 'Great job! Reminder completed 🎉',\n        icon: '/favicon.ico'\n      });\n    }\n  };\n\n  const dismissReminder = (reminderId: string) => {\n    setReminders(prev => \n      prev.map(r => \n        r.id === reminderId \n          ? { ...r, isDismissed: true }\n          : r\n      )\n    );\n  };\n\n  const activeReminders = reminders.filter(r => !r.isDismissed && (!r.isCompleted || showCompleted));\n  const completedCount = reminders.filter(r => r.isCompleted && !r.isDismissed).length;\n\n  const getPriorityColor = (priority: string) => {\n    switch (priority) {\n      case 'high': return 'text-red-600 bg-red-50';\n      case 'medium': return 'text-yellow-600 bg-yellow-50';\n      case 'low': return 'text-green-600 bg-green-50';\n      default: return 'text-gray-600 bg-gray-50';\n    }\n  };\n\n  const getCategoryIcon = (category: string) => {\n    switch (category) {\n      case 'fitness': return '💪';\n      case 'hydration': return '💧';\n      case 'sleep': return '😴';\n      case 'mindfulness': return '🧘';\n      case 'learning': return '📚';\n      case 'work': return '💼';\n      case 'nutrition': return '🍎';\n      default: return '📝';\n    }\n  };\n\n  return (\n    <div className=\"space-y-6\">\n      {/* Header with Controls */}\n      <div className=\"flex items-center justify-between flex-wrap gap-4\">\n        <div className=\"flex items-center gap-3\">\n          <div className=\"flex items-center gap-2\">\n            <Zap className=\"w-5 h-5 text-yellow-500\" />\n            <h2 className=\"text-lg font-semibold\">Smart Reminders</h2>\n          </div>\n          <Badge variant=\"secondary\" className=\"text-xs\">\n            {activeReminders.length} active\n          </Badge>\n          {completedCount > 0 && (\n            <Badge variant=\"outline\" className=\"text-xs text-green-600\">\n              {completedCount} completed\n            </Badge>\n          )}\n        </div>\n        \n        <div className=\"flex items-center gap-4\">\n          <div className=\"flex items-center gap-2 text-sm\">\n            <Bell className=\"w-4 h-4\" />\n            <span>Notifications</span>\n            <Switch \n              checked={notificationsEnabled}\n              onCheckedChange={setNotificationsEnabled}\n            />\n          </div>\n          <div className=\"flex items-center gap-2 text-sm\">\n            <span>Show completed</span>\n            <Switch \n              checked={showCompleted}\n              onCheckedChange={setShowCompleted}\n            />\n          </div>\n        </div>\n      </div>\n\n      {/* Reminders List */}\n      {activeReminders.length === 0 ? (\n        <Card className=\"text-center py-12 bg-white/80 backdrop-blur border-0 shadow-lg\">\n          <CardContent>\n            <AlertCircle className=\"w-12 h-12 mx-auto text-gray-400 mb-4\" />\n            <p className=\"text-lg font-medium text-gray-600 mb-2\">No active reminders</p>\n            <p className=\"text-gray-500\">\n              Add some notes above and I'll automatically detect reminders for you!\n            </p>\n          </CardContent>\n        </Card>\n      ) : (\n        <div className=\"space-y-3\">\n          {activeReminders.map((reminder) => (\n            <Card \n              key={reminder.id} \n              className={`bg-white/80 backdrop-blur border-0 shadow-lg transition-all ${\n                reminder.isCompleted ? 'opacity-60' : 'hover:shadow-xl'\n              }`}\n            >\n              <CardContent className=\"p-4\">\n                <div className=\"flex items-start gap-3\">\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    className=\"p-1 hover:bg-green-100\"\n                    onClick={() => completeReminder(reminder.id)}\n                  >\n                    {reminder.isCompleted ? (\n                      <CheckCircle2 className=\"w-5 h-5 text-green-600\" />\n                    ) : (\n                      <div className=\"w-5 h-5 border-2 border-gray-300 rounded-full\"></div>\n                    )}\n                  </Button>\n                  \n                  <div className=\"flex-1 space-y-2\">\n                    <div className=\"flex items-start justify-between\">\n                      <p className={`font-medium ${reminder.isCompleted ? 'line-through text-gray-500' : ''}`}>\n                        {getCategoryIcon(reminder.category)} {reminder.text}\n                      </p>\n                      <div className=\"flex items-center gap-1\">\n                        <Badge \n                          variant=\"secondary\" \n                          className={`text-xs ${getPriorityColor(reminder.priority)}`}\n                        >\n                          {reminder.priority}\n                        </Badge>\n                        <Button\n                          variant=\"ghost\"\n                          size=\"sm\"\n                          className=\"p-1 hover:bg-red-100\"\n                          onClick={() => dismissReminder(reminder.id)}\n                        >\n                          <XCircle className=\"w-4 h-4 text-gray-400 hover:text-red-500\" />\n                        </Button>\n                      </div>\n                    </div>\n                    \n                    {reminder.suggestedTime && (\n                      <div className=\"flex items-center gap-1 text-sm text-blue-600\">\n                        <Clock className=\"w-3 h-3\" />\n                        <span className=\"capitalize\">{reminder.suggestedTime}</span>\n                      </div>\n                    )}\n                    \n                    <details className=\"text-xs text-gray-500\">\n                      <summary className=\"cursor-pointer hover:text-gray-700\">\n                        View context\n                      </summary>\n                      <p className=\"mt-1 p-2 bg-gray-50 rounded text-xs\">\n                        \"...{reminder.extractedFrom}...\"\n                      </p>\n                    </details>\n                  </div>\n                </div>\n              </CardContent>\n            </Card>\n          ))}\n        </div>\n      )}\n\n      {/* Stats Footer */}\n      <div className=\"text-center text-sm text-gray-500\">\n        🤖 Automatically extracted from your {notes.length} notes using AI pattern recognition\n      </div>\n    </div>\n  );\n}"
    },
    "output": "",
    "metadata": {
      "diagnostics": {},
      "filepath": "/home/user/project/components/smart-reminders.tsx",
      "exists": false
    },
    "title": "components/smart-reminders.tsx",
    "time": {
      "start": 1757857662682,
      "end": 1757857662693
    }
  }
}